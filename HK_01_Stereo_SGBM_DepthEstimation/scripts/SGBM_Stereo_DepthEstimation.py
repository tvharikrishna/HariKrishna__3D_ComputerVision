"""
Depth Estimation from Stereo Images

This script performs depth estimation from a pair of stereo images using the StereoSGBM (Semi-Global Block Matching) algorithm.
The process includes reading stereo image pairs, preprocessing them, computing disparity maps, and generating depth maps.

Author: Venkata Harikrishna, Talapala
GitHub: https://github.com/tvharikrishna

Usage:
Run this script as the main module to perform depth estimation. 
Ensure that the image paths are set correctly to the stereo image pairs.
"""


import cv2
import numpy as np

class DepthEstimation():

    # Constructor with image paths as parameters
    def __init__(self, Left_Image_Path, Right_Image_Path) -> None:
        """
        Initialize the DepthEstimation class with specific camera parameters and StereoSGBM parameters.
        The camera parameters such as focal length and baseline are specific to the Middlebury Stereo Datasets.
        The StereoSGBM (Semi-Global Block Matching) parameters should be adjusted according to the specifics
        of the dataset used.

        More information on the dataset can be found at: https://vision.middlebury.edu/stereo/data/

        Parameters:
        - minDisparity: Minimum disparity considered.
        - numDisparities: Number of disparities considered.
        - blockSize: Size of the block used for matching.
        - P1, P2: Parameters that control the smoothness of the disparity map.
        - disp12MaxDiff: Maximum allowed difference in the left and right disparity maps.
        - uniquenessRatio: Margin by which the best (minimum) computed cost function value should 'win' the second best value.
        - speckleWindowSize, speckleRange: Parameters for speckle filtering.
        - preFilterCap: Truncation value for the prefiltered image pixels.
        - mode: Mode of the StereoSGBM algorithm.
        """

        # Initialize camera parameters
        self.focal_length = 1758.23  
        self.baseline = 97.99  

        # StereoSGBM parameters
        window_size = 7  
        min_disp = 0  
        num_disp = 16 * 13  

        # Create StereoSGBM and WLS filter instances with the given parameters
        self.left_matcher = cv2.StereoSGBM_create(
            minDisparity=min_disp,
            numDisparities=num_disp,
            blockSize=window_size,
            P1=8 * 2 * window_size ** 2,                
            P2=32 * 2 * window_size ** 2,               
            disp12MaxDiff=500,                          
            uniquenessRatio=15,                         
            speckleWindowSize=0,                        
            speckleRange=2,                             
            preFilterCap=60,                            
            mode=cv2.STEREO_SGBM_MODE_SGBM_3WAY         
        )

        # Preprocess images
        self.imgL_gray, self.imgR_gray, self.imgL, self.imgR = DepthEstimation._preprocess(Left_Image_Path, Right_Image_Path)

    # Private method
    def _disparity(self):
        """
        This private method computes the disparity map which is a representation of the depth information obtained
        from a pair of stereo images. It utilizes the Weighted Least Squares (WLS) filter to improve the disparity 
        map generated by the Semi-Global Block Matching (SGBM) algorithm.

        The disparity map is computed separately for the left and right images using the left_matcher, which is an 
        instance of the SGBM algorithm. The computed disparities are then filtered using the WLS filter, which applies 
        a more sophisticated approach to reduce noise and smooth the disparities while preserving edge information. 
        
        The WLS filter is configured with lambda and sigma values, which determine the amount of regularization and 
        the range of influence of each pixel, respectively. After filtering, the disparity map is normalized to a 
        range suitable for visualization.

        Returns:
            A normalized, uint8 type disparity map ready for visualization or further processing.
        """

        lmbda = 250000  
        sigma = 1.5  
        wls_filter = cv2.ximgproc.createDisparityWLSFilter(matcher_left=self.left_matcher)
        wls_filter.setLambda(lmbda)
        wls_filter.setSigmaColor(sigma)

        # Compute disparity maps for the left and right images
        displ = self.left_matcher.compute(self.imgL_gray, self.imgR_gray).astype(np.float32)
        dispr = cv2.ximgproc.createRightMatcher(self.left_matcher).compute(self.imgR_gray, self.imgL_gray).astype(np.float32)

        # Apply Weighted Least Squares filtering to disparity maps
        filteredImg = wls_filter.filter(displ, self.imgL, None, dispr)

        # Normalize the filtered image for visualization purposes
        filteredImg = cv2.normalize(src=filteredImg, dst=filteredImg, beta=0, alpha=255, norm_type=cv2.NORM_MINMAX)
        filteredImg = np.uint8(filteredImg)

        return filteredImg

    # Method to calculate and optionally save or display depth maps
    def depth(self, save_images=False, display_images=False):
        """
        This method computes the depth map from the disparity map generated by `_disparity`.
        The depth map is computed using the focal length and baseline of the camera setup. 
        Non-zero disparity values are used to calculate the depth, while zero disparity values are managed to avoid division by zero.
        The resulting depth map is then normalized and clipped for better visualization. 
        This normalized depth map can be visualized using a color map, which can be particularly helpful for understanding the depth variations in the scene.
        
        The method also provides options to save the resulting images to disk and/or display them on screen.
        Saving is done for the disparity map, the raw depth map, and the color-mapped depth map. Displaying the images involves opening windowed views of each map.

        Parameters:
        - save_images (bool): If True, saves the disparity map and depth maps to the disk.
        - display_images (bool): If True, displays the images on screen.

        The images are saved with predefined filenames in a 'generated_images' directory, and the display will show until a key is pressed.
        """
        
        # Get the filtered disparity map
        filteredImg = self._disparity()

        # Calculate the depth map
        depth_map = np.zeros_like(filteredImg, dtype=np.float32)
        nonzero_disparity = filteredImg > 0
        depth_map[nonzero_disparity] = (self.focal_length * self.baseline) / (filteredImg[nonzero_disparity] + (filteredImg[nonzero_disparity] == 0))

        # Normalize and clip depth map for visualization
        max_depth = np.percentile(depth_map[nonzero_disparity], 95)
        depth_map_display = np.clip(depth_map, 0, max_depth)
        depth_map_display = 255 * (depth_map_display / max_depth)
        depth_map_display = np.uint8(depth_map_display)

        # Apply a color map for better visualization
        depth_map_display_jet_color = cv2.applyColorMap(depth_map_display, cv2.COLORMAP_INFERNO)

        # Save images if required
        if save_images:
            cv2.imwrite('generated_images/Disparity_Map.png', filteredImg)
            cv2.imwrite('generated_images/Depth_Map.png', depth_map_display)
            cv2.imwrite('generated_images/Depth_Map_Color.png', depth_map_display_jet_color)

        # Display images if required
        if display_images:
            cv2.imshow('Filtered Disparity Map', filteredImg)
            cv2.imshow('Depth Map', depth_map_display)
            cv2.imshow('Depth Color Map', depth_map_display_jet_color)
            cv2.waitKey(0) 
            cv2.destroyAllWindows()

    # Static method for preprocessing images
    @staticmethod
    def _preprocess(Left_Image_Path: str, Right_Image_Path: str):
            """
            Preprocess the input images for disparity map generation. This method reads the images from the given paths
            and converts them to grayscale, which is a common preprocessing step for disparity calculation.

            Parameters:
            - Left_Image_Path (str): The file path to the left image.
            - Right_Image_Path (str): The file path to the right image.

            Returns:
            Tuple: A tuple containing the grayscale left image, grayscale right image, original left image, and original right image.
            """
                
            # Read and convert images to grayscale
            imgL = cv2.imread(Left_Image_Path, cv2.IMREAD_COLOR)
            imgR = cv2.imread(Right_Image_Path, cv2.IMREAD_COLOR)
            imgL_gray = cv2.cvtColor(imgL, cv2.COLOR_BGR2GRAY)
            imgR_gray = cv2.cvtColor(imgR, cv2.COLOR_BGR2GRAY)

            # Return preprocessed images
            return imgL_gray, imgR_gray, imgL, imgR


if __name__ == "__main__":
    """
    This script when executed as the main program performs depth estimation from a pair of stereo images.
    It uses pre-set paths to the left and right images, creates an instance of the DepthEstimation class,
    and then calls the depth method to calculate and save the depth map images.
    """
    
    # Paths to left and right images
    Left_Image_Path = 'data/img1.png'
    Right_Image_Path = 'data/img2.png'

    # Create an instance of DepthEstimation and calculate depth
    depth_est = DepthEstimation(Left_Image_Path='data/img1.png', Right_Image_Path='data/img2.png')
    depth_est.depth(save_images=True)
